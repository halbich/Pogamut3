<?xml version="1.0" encoding="UTF-8"?>

<!--
    Document   : yylex.xsl
    Created on : 14. duben 2008, 11:15
    Author     : student
    Description:
        Purpose of transformation follows.
-->

<xsl:stylesheet 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  version="2.0">
      
<xsl:output method="text"/>

<xsl:template name="firstLetter">
	
	<xsl:param name="toconvert" />
	<xsl:param name="conversion" />
	<xsl:variable name="lower" select="'abcdefghijklmnopqrstuvwxyz'"/>
    <xsl:variable name="upper" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>

	<xsl:choose>
		<xsl:when test="$conversion='upper'">
			<xsl:variable name="first" select="translate(substring($toconvert,1,1),$lower,$upper)" />
			<xsl:variable name="rest" select="substring($toconvert, 2, string-length($toconvert))" />
			<xsl:value-of select="concat($first, $rest)"/>
		</xsl:when>
		<xsl:when test="$conversion='lower'">
			<xsl:variable name="first" select="translate(substring($toconvert,1,1),$upper,$lower)" />
			<xsl:variable name="rest" select="substring($toconvert, 2, string-length($toconvert))" />
			<xsl:value-of select="concat($first, $rest)"/>
		</xsl:when>		
		<xsl:otherwise>
			<xsl:value-of select="concat($conversion, $toconvert)" />
		</xsl:otherwise>
	</xsl:choose>
</xsl:template>
    
<xsl:template match="/">
<![CDATA[
// generated by yylex.xsl from PogamutUT2004\src\gb2004\messages\FlexGenerator.xslt, called from ant script build.xml
// file was further processed by JFlex to create class Yylex (yylex.java)
]]>
package <xsl:value-of select="/messages/settings/jflexsettings/jflexpackage/@package"/>;

import java.io.Reader;

// imports from MessageObjectsList.xml/gbmessages/settings/jflexsettings/javaimport
<xsl:for-each select="/messages/settings/jflexsettings/javaimport">
<xsl:text>import </xsl:text><xsl:value-of select="@import"/><xsl:text>;
</xsl:text>
</xsl:for-each>

<![CDATA[
// beggining of the yylex definition
%%

// declare result class Yylex as public
%public

// return type of the yylex() method should be Object
%type InfoMessage

%implements IUT2004Yylex

// default return value should be null
%eofval{
throw new ParserEOFException(this);
%eofval}

// following block is containing code that will be added to the generated lexical parser yylex.java
%{
	
 	public static final String DELIMITERS_STANDARD = " {}";
 	public static final String DELIMITERS_EXTENDED = " {},";

	/** Map for list of String, Double */
	protected Map<Integer, Double> mapIntIDDouble = null;

	/** Map for list of String, Double */
	protected Map<Integer, Double> mapIntDouble = null;
	
	/** parser reference, this parser will be used for translation of UnrealID to IntID */
	protected UnrealIdTranslator translator = null;
	
	/** object that is used to translate messages into objects */ 
	protected ItemTranslator itemTranslator = null;
	
	/** observer for the yylex for reporting exceptions */	
	protected IYylexObserver observer = null;
	
	/** object that is used to translate strings into item types */
	protected ItemTypeTranslator itemTypeTranslator;
	
	/** time in the UT2004 */	
	protected double ut2004Time = 0;
	
	public Yylex(){
	}
	
	public void setReader(Reader reader) {
		yyreset(reader);
	}
	
	public void close() throws java.io.IOException {
		yyclose();
	}
	
	public void setItemTranslator(ItemTranslator translator) {
		this.itemTranslator = translator;
	}
	
	@Override
	public void setItemTypeTranslator(ItemTypeTranslator translator) {
		this.itemTypeTranslator = translator;
	}
	
	public void setObserver(IYylexObserver observer) {
		this.observer = observer;
	}
	
	/**
	 * Set parser translating UnrealID to IntID.
	 * This function should be called after constructor, I dont know how to define constructor, so this will do.
	 */
	public void setTranslator(UnrealIdTranslator translator) {
		this.translator = translator;
	}
	
	public void setTime(IWorldObjectUpdatedEvent obj, double time) {
       //we have to multiply by 1000 to convert from floats to longs, larger number is not required because of the way GB2004 work
       setPropertyByReflection( obj, "SimTime", long.class, (long)(ut2004Time*1000) );
	}
	
	public void setTime(IWorldEvent obj, double time) {
	   //we have to multiply by 1000 to convert from floats to longs, larger number is not required because of the way GB2004 work
	   setPropertyByReflection( obj, "SimTime", long.class, (long)(ut2004Time*1000) );
	}
	
	/** Set property of an object by reflection
	 * 
	 * Setter method name is expected to follow name convention "set<PropertyName>", where the first letter of property name is upper case.
	 * Potential access restriction of the setter method is overriden via reflection.
	 * 
	 * @param object the object
	 * @param propertyName property name
	 * @param valueType property value / setter argument type
	 * @param value value to set
	 */
	protected <T> void setPropertyByReflection( Object object, String propertyName, Class<T> valueType, T value ) {
	    try {
            Method m = null;
            // we have to look for definition in each ancestor starting with the class itself
            Class<?> ancestorClass = object.getClass();
            Class<?>[] argumentTypes = new Class[]{valueType};
            String setterName = "set"+propertyName.substring( 0, 1 ).toUpperCase()+propertyName.substring( 1 );
            while ( m == null ) {
	            try {
	                m = ancestorClass.getDeclaredMethod( setterName, argumentTypes );
	            } catch ( NoSuchMethodException e ) {
	                ancestorClass = ancestorClass.getSuperclass();
	                if ( ancestorClass == null ) {
	                    throw e;
	                }
	            }
	        }
            m.setAccessible( true );
            m.invoke( object, value );
        } catch (Exception e) {
            exceptionOccured(e, "Can't set "+propertyName+" to message " + object.getClass() );
        }
	}
	
	/**
	 * Logs the exception if observer present, or print it to System.out.
	 * <BR><BR>
	 * Does not throw the exception...
	 * <BR><BR>
	 * If exception 'e' is null, only info message is written to logs.
	 * @param e
	 * @param info	 
	 */
	protected void exceptionOccured(Exception e, String info) {
		IYylexObserver currentObserver = this.observer;
		if (currentObserver != null) {			
			currentObserver.exception(e, info != null ? info : "--empty info--");
		} else {
			System.out.println("Yylex exception: " + info);
			if (e != null) e.printStackTrace(); 
		}
	}
	
	/**
	 * Send the warning to observer or prints it to the console.
	 */
	protected void warning(String info) {
		IYylexObserver currentObserver = this.observer;
		if (currentObserver != null) {			
			currentObserver.warning(info != null ? info : "--empty warning--");
		} else {
			System.out.println("Yylex warning: " + info);			 
		}
	}
	
	/**
     * This method should be overriden to parse additional messages, that are not part of PogamutUDK Core.
     * This method is called whenever the parser meets a message name it does not recognize. If the message is 
     * recognized by overriding class, it should return new instance of a message the name represents. Otherwise it should return null.
     * The newly created message is then accesible for parameter setting via {@link #getParsedObject() }.
     * For further discussion on how this is done see <a href="http://pogamut.cuni.cz/pogamut-devel/doku.php?id=guidelines:adding_gamebots_message_to_pogamut_java">wiki article</a>.
     * @param messageName
     * @see #tryParsingUnprocessedMessageParameter(java.lang.String, java.lang.String) 
     * @return New message or null if not recognized
     */                       
    protected InfoMessage tryParsingUnprocessedMessage(String messageName){
        return null;
    }
        
    /**
     * This method should be overridden to parse parameters of additional messages that are not part of PogamuUDK Core.
     * Once the message was recognized by {@link #tryParsingUnprocessedMessage(java.lang.String) } this method
     * is called for every parameter.
     * @param paramName The name of the parameter as appeared in the Gamebots message
     * @param wholeParamText Whole text of the parameter part of message (contains the param name) - this string can be directly passed to 
     * xxxValue methods of this class to obtain translated values for basically all usable datatypes. If this is not enough, use {@link #getToken(java.lang.String, int) } 
     * to extract desired part of the message text (the value has index 1)
     * @see #tryParsingUnprocessedMessage(java.lang.String) 
     * @return 
     */        
    protected boolean tryParsingUnprocessedMessageParameter(String paramName, String wholeParamText){
        return false;
    }
        
	/**
	 * Returns 'num'-th token from 'text' using 'delimiters'.
	 * <BR><BR>
	 * Use only IFF you're getting only one token from 'text'.
	 * @param text
	 * @param delimiters
	 * @return String token
	 */ 
	protected String getToken(String text, String delimiters, int num) {
		StringTokenizer st = new StringTokenizer(text, delimiters);
		while (num-- > 0 && st.hasMoreTokens()) {
			st.nextToken();
		}
		try {
			return st.nextToken();
		} catch (Exception e) {
			exceptionOccured(e, "Can't get " + num + "-th token from text '"+text+"' using delimiters '"+delimiters+"'.");
			return null;
		}
	}
	
	/**
	 * Returns 'num'-th token from 'text' using DELIMITERS_STANDARD.
	 * <BR><BR>
	 * Use only IFF you're getting only one token from 'text'.
	 * @param text
	 * @return String token
	 */ 
	protected String getToken(String text, int num) {
		return getToken(text, DELIMITERS_STANDARD, num);		
	}

	/**
	 * Return an integer from num token in txt.
	 * <BR><BR>
	 * Integer token is expected to be 'second token' in the 'txt' using delimiters " {}".
	 * 
	 * @param  txt  text of parameter
	 * @return Integer from given token.
	 */
	protected int intValue( String txt  ) {
		if (txt == null || txt.toLowerCase().equals("none")) return UnrealUtils.iNT_NONE;
		try {
        	return Integer.parseInt(getToken(txt, 1));
        } catch (NullPointerException e) {
        	warning("Can't get int token from text '"+txt+"'.");
        	return -1;
        } catch (NumberFormatException e) {
        	exceptionOccured(e, "Wrong int number format in '"+txt+".");
        	return -1; 
        } catch (Exception e) {
        	exceptionOccured(e, "Can't get int token from text '"+txt+"'.");
        	return -1;
        }
	}
	
	/**
	 * Return a long from num token in txt.
	 * <BR><BR>
	 * Long token is expected to be 'second token' in the 'txt' using delimiters " {}".
	 * 
	 * @param  txt  text of parameter
	 * @return Integer from given token.
	 */
	protected long longValue( String txt  ) {
		if (txt == null || txt.toLowerCase().equals("none")) return UnrealUtils.lONG_NONE;
		try {
        	return Long.parseLong(getToken(txt, 1));
        } catch (NullPointerException e) {
        	warning("Can't get long token from text '"+txt+"'.");
        	return -1;
        } catch (NumberFormatException e) {
        	exceptionOccured(e, "Wrong long number format in '"+txt+".");
        	return -1; 
        } catch (Exception e) {
        	exceptionOccured(e, "Can't get long token from text '"+txt+"'.");
        	return -1;
        }
	}
	
	/**
	 * Return an integer from num token in txt.
	 * <BR><BR>
	 * Integer token is expected to be 'second token' in the 'txt' using delimiters " {}".
	 * 
	 * @param  txt  text of parameter
	 * @return Integer from given token.
	 */
	protected Integer integerValue( String txt  ) {
		if (txt == null || txt.toLowerCase().equals("none")) return UnrealUtils.INT_NONE;
		try {
        	return Integer.parseInt(getToken(txt, 1));
        } catch (NullPointerException e) {
        	warning("Can't get int token from text '"+txt+"'.");
        	return null;
        } catch (NumberFormatException e) {
        	exceptionOccured(e, "Wrong int number format in '"+txt+".");
        	return null; 
        } catch (Exception e) {
        	exceptionOccured(e, "Can't get int token from text '"+txt+"'.");
        	return null;
        }
	}

	
	/**
	 * Return a double from num token in txt.
	 * <BR><BR>
	 * Num token is expected to be 'second token' in the 'txt' using delimiters " {}".	 
	 * 
	 * @param  txt  text of parameter
	 * @return Double from given token.
	 */
	protected double doubleValue(String txt) {
		if (txt == null || txt.toLowerCase().equals("none")) return UnrealUtils.dOUBLE_NONE;
		try {
        	return Double.parseDouble(getToken(txt, 1));
        } catch (NullPointerException e) {
        	warning("Can't get double token from text '"+txt+"'.");
        	return -1;
        } catch (NumberFormatException e) {
        	exceptionOccured(e, "Wrong double number format in '"+txt+".");
        	return -1; 
        } catch (Exception e) {
        	exceptionOccured(e, "Can't get double token from text '"+txt+"'.");
        	return -1;
        }
	}
	
	/**
	 * Return a float from num token in txt.
	 * <BR><BR>
	 * Num token is expected to be 'second token' in the 'txt' using delimiters " {}".	 
	 * 
	 * @param  txt  text of parameter
	 * @return Float from given token.
	 */
	protected float floatValue(String txt) {
		if (txt == null || txt.toLowerCase().equals("none")) return UnrealUtils.fLOAT_NONE;
		try {
        	return Float.parseFloat(getToken(txt, 1));
        } catch (NullPointerException e) {
        	warning("Can't get float token from text '"+txt+"'.");
        	return -1;
        } catch (NumberFormatException e) {
        	exceptionOccured(e, "Wrong float number format in '"+txt+".");
        	return -1; 
        } catch (Exception e) {
        	exceptionOccured(e, "Can't get float token from text '"+txt+"'.");
        	return -1;
        }
	}
	
    /**
	 * Return a triple (double[]{x,y,z})
	 * starting from num token(tokens are separated by space) in 'txt'
	 * 
	 * @param  txt  text of parameter
	 * @return Array of three doubles from given token.
	 */
	protected double[] getTriple( String txt ) {
		StringTokenizer st = new StringTokenizer(txt, DELIMITERS_EXTENDED);
		
		int num = 1;
		while (num-- > 0 && st.hasMoreTokens()) {
			st.nextToken();
		}
		
		// now we should have an token with integer
		try {
			double t1,t2,t3;
			t1 = new Double(st.nextToken()).doubleValue();
			t2 = new Double(st.nextToken()).doubleValue();
			t3 = new Double(st.nextToken()).doubleValue();
        	return new double[]{t1,t2,t3};
        } catch (NumberFormatException e) {
        	exceptionOccured(e, "Wrong double number format in '"+txt+".");
        	return null; 
        } catch (Exception e) {
        	exceptionOccured(e, "Can't get triple from text '"+txt+"'.");
        	return null;
        }
	}
	
	/**
	 * Return a Location instance starting from num token(tokens are separated by space) in txt
	 * 
	 * @param  txt  text of parameter
	 * @return Location from given token.
	 */
	protected Location locationValue(String txt) {
		if (txt == null || txt.toLowerCase().equals("none")) return Location.NONE;		
		double[] triple = getTriple(txt);
		try {
			return new Location(triple[0], triple[1], triple[2]);
		} catch (NullPointerException e) {
			warning("Can't get Location from text '"+txt+"'.");
			return Location.ZERO;
		} catch (Exception e) {
			exceptionOccured(e, "Can't get Location from text '"+txt+"'.");
			return null;
		}
	}
	
	/**
     * Return an ItemType instance.
     * 
     * @param  txt  text of parameter
     * @return ItemType from given token.
     */
    protected ItemType itemTypeValue(String txt) {
        return itemTypeTranslator.get(getToken(txt, 1));
    }
    
    protected ItemDescriptor itemDescriptorValue(ItemType type) {
    	return itemTranslator.getDescriptor(type);
    }
    
    /**
     * Return a Category of the item.
     * @param  txt  text of parameter
     * @return ItemType.Category from given token.
     */ 
    protected ItemType.Category categoryValue(String txt) {
    	if (txt == null || txt.toLowerCase().equals("none")) return ItemType.Category.NONE;
    	try {
    		return ItemType.Category.valueOf(getToken(txt, 1).toUpperCase());
    	} catch (IllegalArgumentException e) {
    		return ItemType.Category.OTHER;
    	}
    }
	
	/**
	 * Return a Velocity instance starting from num token(tokens are separated by space) in txt
	 * 
	 * @param  txt  text of parameter
	 * @return Velocity from given token.
	 */
	protected Velocity velocityValue(String txt) {
		if (txt == null || txt.toLowerCase().equals("none")) return Velocity.NONE;
		double[] triple = getTriple(txt);
		try {
			return new Velocity(triple[0], triple[1], triple[2]);
		} catch (NullPointerException e) {
			warning("Can't get Velocity from text '"+txt+"'.");
			return Velocity.ZERO;
		} catch (Exception e) {
			exceptionOccured(e, "Can't get Velocity from text '"+txt+"'.");
			return null;
		}
	}

	/**
	 * Return a Rotation instance starting from num token(tokens are separated by space) in txt
	 * 
	 * @param  txt  text of parameter
	 * @return Rotation from given token.
	 */
	protected Rotation rotationValue(String txt) {
		if (txt == null || txt.toLowerCase().equals("none")) return Rotation.NONE;
		double[] triple = getTriple(txt);
		try {
			return new Rotation(triple[0], triple[1], triple[2]);
		} catch (NullPointerException e) {
			warning("Can't get Rotation from text '"+txt+"'.");
			return Rotation.ZERO;
		} catch (Exception e) {
			exceptionOccured(e, "Can't get Rotation from text '"+txt+"'.");
			return null;
		}
	}
	
	/**
	 * Return a Point3d instance starting from num token(tokens are separated by space) in txt
	 * 
	 * @param  txt  text of parameter
	 * @return Point3d from given token.
	 */
	protected Point3d point3dValue(String txt) {
		if (txt == null || txt.toLowerCase().equals("none")) return UnrealUtils.POINT3D_NONE;
		double[] triple = getTriple(txt);
		try {
			return new Point3d(triple[0], triple[1], triple[2]);
		} catch (NullPointerException e) {
			warning("Can't get Point3d from text '"+txt+"'.");
        	return new Point3d(0,0,0);
		} catch (Exception e) {
        	exceptionOccured(e, "Can't get Point3d from text '"+txt+"'.");
        	return null;
        }
	}
	
	/**
	 * Return a Vector3d instance starting from num token(tokens are separated by space) in txt
	 * 
	 * @param  txt  text of parameter
	 * @return Vector3d from given token.
	 */
	protected Vector3d vector3dValue(String txt) {
		if (txt == null || txt.toLowerCase().equals("none")) return UnrealUtils.VECTOR3D_NONE;
		double[] triple = getTriple(txt);
		try {
			return new Vector3d(triple[0], triple[1], triple[2]);
		} catch (NullPointerException e) {
			warning("Can't get Vector3d from text '"+txt+"'.");
        	return new Vector3d(0,0,0);
		} catch (Exception e) {
        	exceptionOccured(e, "Can't get Vector3d from text '"+txt+"'.");
        	return null;
        }
	}
	
	/**
	 * Returns string for parsed token.
	 *	 
	 * @param  txt  text of parameter
	 * @return String from given token.
	 */
	protected String stringValue( String txt ) {	
		try {
        	int index = txt.indexOf(" ");
			if (index == -1) {
				warning("Can't get string token from text '" + txt + "'.");
				return "";
			}
			String string = txt.substring(index+1, txt.length()-1);
        	if (string != null) {
				return string;        	        		
        	} else {
        		warning("Can't get string token from text '"+txt+"'.");
        		return "";
        	}
        } catch (Exception e) {
        	exceptionOccured(e, "Can't get string token from text '"+txt+"'.");
        	return "";
        }
	}
	
	/**
	 * Returns UnrealId for parsed token.
	 *	 
	 * @param  txt  text of parameter
	 * @return StringId from given token.
	 */
	protected UnrealId stringIdValue( String txt ) {
		if (txt == null || txt.toLowerCase().equals("none")) return UnrealId.NONE;
		return unrealIdValue(txt);				
	}
	
	/**
	 * Return a boolean from boolean token in txt.
	 * <BR><BR>
	 * Boolean token is expected to be 'second token' in the 'txt' using delimiters " {}".	 
	 * 
	 * @param  txt  text of parameter
	 * @return Boolean from given token.
	 */
	protected boolean booleanValue(String txt) {
		try {
        	String token = getToken(txt, 1);
        	if (token.equals("True")) return true;
        	if (token.equals("true")) return true;
        	else return false;
        } catch (NullPointerException e) {
        	warning("Can't get boolean token from text '"+txt+"'.");
        	return false; 
        } catch (Exception e) {
        	exceptionOccured(e, "Can't get boolean token from text '"+txt+"'.");
        	return false;
        }
	}
	
	/**
	 * Return an UnrealId instance from identificator token in txt.
	 * <BR><BR>
	 * Boolean token is expected to be 'second token' in the 'txt' using delimiters " {}".	 
	 * 
	 * @param  txt  text of parameter
	 * @return UnrealId from given token.
	 */
	protected UnrealId unrealIdValue(String txt) {
		if (txt == null || txt.toLowerCase().equals("none")) return UnrealId.NONE;
		try {
        	String token = getToken(txt, 1);
        	if (token == null) {
        		warning("Can't get UnrealId token from text '"+txt+"'.");
        		return null;
        	}
        	return translator.getId(token);
        } catch (NullPointerException e) {
        	warning("Can't get UnrealId token from text '"+txt+"' (translator not set?).");
        	return null; 
        } catch (Exception e) {
        	exceptionOccured(e, "Can't get UnrealId token from text '"+txt+"'.");
        	return null;
        }
	}
	
	/**
	 * Return an UnrealId instance from identificator token in txt.
	 * <BR><BR>
	 * Boolean token is expected to be 'second token' in the 'txt' using delimiters " {}".	 
	 * 
	 * @param  txt  text of parameter
	 * @return UnrealId from given token.
	 */
	protected UnrealId worldObjectIdValue(String txt) {
		if (txt == null || txt.toLowerCase().equals("none")) return UnrealId.NONE;
		try {
        	String token = getToken(txt, 1);
        	if (token == null) {
        		warning("Can't get UnrealId token from text '"+txt+"'.");
        		return null;
        	}
        	return translator.getId(token);
        } catch (NullPointerException e) {
        	warning("Can't get UnrealId token from text '"+txt+"' (translator not set?).");
        	return null; 
        } catch (Exception e) {
        	exceptionOccured(e, "Can't get UnrealId token from text '"+txt+"'.");
        	return null;
        }
	}
	
	private ITeamId teamId;
	
	/**
	 * Sets teamId that has to be slipped to every {@link IWorldObjectUpdatedEvent}.
	 */
	public void setTeamId(ITeamId teamId) {
		this.teamId = teamId;
	}
	
	private void setTeamId(IWorldObjectUpdatedEvent obj) {
       setPropertyByReflection( obj, "TeamId", ITeamId.class, (ITeamId)teamId );
	}
		
    // this is stack with static size, so it can overflow... theoreticly... No.
    private int[] stack = new int[10];
    private int stack_pos = 0;
  
 	// actual object that is being parsed 
    protected Object actObj;
  
    /**
     * Change state to state and push original state to stack, so parser can return in state_return
     */
    private void state_go(int state)
    {
  	    stack[stack_pos++] = yystate();
  	    yybegin(state);
    }
  
    /**
     * Return to previous state.
     */
    private void state_return()
    {
  	    yybegin(stack[--stack_pos]);
    }
%} 

%line
%char]]>
%state UNPROCESSED_MESSAGE<xsl:for-each select="/messages/infomessages/messageobject">, MSG_<xsl:value-of select="@message"/></xsl:for-each>
<![CDATA[%full
%standalone
%unicode

ALPHA=[A-Za-z]
ALPHA_NUMERIC={ALPHA}|{DIGIT}
SEP=[_\-.]
ALPHA_NUMERIC_SEP = {ALPHA}|{DIGIT}|{SEP}
UNREALID={ALPHA_NUMERIC_SEP}+
MESSAGENAME={ALPHA_NUMERIC}+
WORLDOBJECTID={ALPHA_NUMERIC_SEP}+

DIGIT=[0-9]
NONNEWLINE_WHITE_SPACE_CHAR=[\ \t\b\012]
NEWLINE=\r|\n|\r\n
WHITE_SPACE_CHAR=[\n\r\ \t\b\012]
UINT = {DIGIT}+

FLit1    = {DIGIT}+ \. {DIGIT}* 
FLit2    = \. {DIGIT}+ 
FLit3    = {DIGIT}+

INT = \-? {UINT}
INTEGER = \-? {UINT}
LONG = \-? {UINT}
FLOAT    = \-?({FLit1}|{FLit2}|{FLit3})
DOUBLE   = \-?({FLit1}|{FLit2}|{FLit3})
STRING=[^}]* 
STRINGID=[^}]+
ITEMTYPE = [^}]+
CATEGORY = [^}]+
POINT3D = {FLOAT} \, {FLOAT} \, {FLOAT}
VECTOR3D = {FLOAT} \, {FLOAT} \, {FLOAT}
LOCATION = {FLOAT} \, {FLOAT} \, {FLOAT}
VELOCITY = {FLOAT} \, {FLOAT} \, {FLOAT}
ROTATION = {FLOAT} \, {FLOAT} \, {FLOAT}
BOOLEAN = "True" | "False" | "true" | "false" | "Falso" | "falso"
SPACE= " "

%% 

<YYINITIAL> {
]]>
<xsl:for-each select="//messageobject">
  "<xsl:value-of select="@message"/>" {
  	<xsl:choose>
  		<xsl:when test="@type='ObjectUpdate'">
  			actObj = new <xsl:value-of select="@name"/>Message();
  		</xsl:when>
  		<xsl:otherwise>
  			actObj = new <xsl:value-of select="@name"/>();
  		</xsl:otherwise>
  	</xsl:choose>
  	state_go(MSG_<xsl:value-of select="@message"/>);
  }
</xsl:for-each>
<![CDATA[
}
]]>

<xsl:for-each select="//messageobject">
<![CDATA[<MSG_]]><xsl:value-of select="@message"/><![CDATA[>]]> {
  	<xsl:for-each select="property">
	  	<xsl:if test="not(@jflex)">
		  	<xsl:variable name="type" select="@type" />
			"{<xsl:value-of select="@name"/> " {<xsl:value-of select="upper-case($type)"/>} "}" {
				<xsl:choose>
  					<xsl:when test="../@type='ObjectUpdate'">
						((<xsl:value-of select="../@name"/>Message)actObj).
					</xsl:when>
					<xsl:otherwise>
						((<xsl:value-of select="../@name"/>)actObj).
					</xsl:otherwise>
				</xsl:choose>
				<xsl:value-of select="@name"/> = <xsl:call-template name="firstLetter"><xsl:with-param name="conversion" select="'lower'"/><xsl:with-param name="toconvert" select="$type"/></xsl:call-template>Value(yytext());
				<xsl:if test="../@type='ObjectUpdate'">
					((<xsl:value-of select="../@name"/>Message)actObj).<xsl:value-of select="@name"/>_Set = true;
				</xsl:if>				
				<xsl:if test="./extra/code/yylex">
					<xsl:value-of select="./extra/code/yylex"/>
				</xsl:if>
			}
		</xsl:if>
  	</xsl:for-each>
  	
	. {
		if (!yytext().equals(" ")) {
			warning("State MSG_<xsl:value-of select="@message"/> unprocessed: " + yytext());
		}
  	}
}
</xsl:for-each>

<![CDATA[

{WHITE_SPACE_CHAR} { }

{NEWLINE} { 
		// reset scanning
		stack_pos = 0;
 		yybegin(YYINITIAL);
 		if (actObj != null)
 		{ 			
 			InfoMessage obj = (InfoMessage) actObj;
 			
 			if (obj instanceof IWorldObjectUpdatedEvent) {
 				setTeamId((IWorldObjectUpdatedEvent)obj);
 			}
 			
 			if (obj instanceof BeginMessage) {
                ut2004Time = ((BeginMessage)obj).getTime();
                setTime((IWorldEvent)obj, ut2004Time);
            } else
            if (obj instanceof AliveMessage) {
                ut2004Time = ((AliveMessage)obj).getTime();
                setTime((IWorldObjectUpdatedEvent)obj, ut2004Time);
            } else
            if (obj instanceof IWorldObjectUpdatedEvent) {
 				setTime((IWorldObjectUpdatedEvent)obj, ut2004Time);
 			} else
 			if (obj instanceof IWorldEvent) {
 				setTime((IWorldEvent)obj, ut2004Time);
 			}
 			
 			actObj = null;
 			return obj;
 		}
}

<UNPROCESSED_MESSAGE> {
    "{" {STRINGID} " " {STRING} "}" {
        String text = yytext();
        if(!tryParsingUnprocessedMessageParameter(getToken(text,0), text)) {
            warning("Illegal unprocessed message parameter: <" + yytext() + ">");  
        }
    }
    . {
            if (!yytext().equals(" ")) {
                    warning("State UNPROCESSED_MESSAGE unprocessed: " + yytext());
            }
    }
    
}

{MESSAGENAME}* {
  InfoMessage obj = tryParsingUnprocessedMessage(yytext());
  if(obj != null){
    actObj = obj;
    state_go(UNPROCESSED_MESSAGE);
  } else {
    warning("Illegal character sequence: <" + yytext() + "> + currentstate "+ yystate());  
  }
}

. {
  warning("Illegal character: <" + yytext() + "> + currentstate "+ yystate());
}

]]>

</xsl:template>

</xsl:stylesheet>
